<!DOCTYPE html>
<html lang="ko">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    <title>Jump Game - Balanced</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh; 
            background-color: #f0f0f0;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
        #gameCanvas {
            background-color: #222;
            border: 5px solid #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 100%;
            max-height: 100vh; 
            object-fit: contain; 
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="700"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- [1. 오디오 시스템] ---
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    const gravity = 0.5;
    const floorY = canvas.height - 60;

    const player = {
        angle: 0,
        width: 64,
        height: 64,
        x: (canvas.width / 2) - 32,
        y: floorY,
        vx: 0,
        vy: 0,
        isJumping: false,
        standingOn: null // 현재 밟고 있는 발판 정보 저장용
    };

    function draw8GridBlockyPlayer(ctx, x, y, width, height) {
        const gridSize = 8;
        const pixelSize = width / gridSize;
        const colors = {
            hair: "#BCA9E1", skin: "#FFF0ED", ribbon: "#E74C3C",
            top: "#FFFFFF", sock: "#565056", eye1: "#66A1DA", eye2: "#FBB76F"
        };
        ctx.save();
        const p = (gx, gy, color) => {
            ctx.fillStyle = color;
            ctx.fillRect(x + gx * pixelSize, y + gy * pixelSize, pixelSize + 0.5, pixelSize + 0.5);
        };
        p(1, -1, colors.hair); p(6, -1, colors.hair);
        for(let i=0; i<8; i++) p(i, 0, colors.hair);
        for(let i=0; i<8; i++) p(i, 1, colors.hair);
        for(let j=2; j<=4; j++) {
            p(0, j, colors.hair); for(let i=1; i<7; i++) p(i, j, colors.skin); p(7, j, colors.hair);
        }
        p(2, 3, colors.eye1); p(5, 3, colors.eye2);
        p(3, 2, colors.hair); p(4, 2, colors.hair);
        p(0, 5, colors.top); p(1, 5, colors.top);
        p(2, 5, colors.ribbon); p(5, 5, colors.ribbon);
        p(3, 5, colors.top); p(4, 5, colors.top);
        p(6, 5, colors.top); p(7, 5, colors.top);
        for(let i=1; i<7; i++) p(i, 6, colors.ribbon);
        p(0, 6, colors.top); p(7, 6, colors.top);
        p(1, 7, colors.sock); p(2, 7, colors.sock);
        p(5, 7, colors.sock); p(6, 7, colors.sock);
        ctx.restore();
    }

    let power = 0;
    let isCharging = false;
    const maxPower = 20;
    let jumpDirection = 1;
    let platforms = [];
    let cameraY = 0;
    const cameraSmoothness = 0.2;
    let lastTime = 0;
    let lastMovingIndex = 0; 

function startCharge() {
    initAudio();
    
    // [추가] 스페이스바가 눌린 상태에서 클릭하면 위로 상승 (테스트용)
    if (isSpacePressed) {
        player.isJumping = true;
        player.standingOn = null;
        player.vy = -30; // 위로 솟구치는 힘 (숫자가 클수록 더 높이 점프)
        player.vx = 0;   // 옆으로는 움직이지 않게 설정
        return; // 일반 점프 기모으기 로직을 실행하지 않고 종료
    }

    if (!player.isJumping) {
        isCharging = true;
        power = 0;
    }
}

    function endCharge() {
        if (isCharging) {
            jump();
            isCharging = false;
        }
    }

    window.addEventListener('mousedown', startCharge);
    window.addEventListener('mouseup', endCharge);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startCharge(); }, { passive: false });
    canvas.addEventListener('touchend', (e) => { e.preventDefault(); endCharge(); }, { passive: false });

let isSpacePressed = false; // 테스트용 스페이스바가 눌려있는지 확인
// 키보드 이벤트 리스너 추가
window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') isSpacePressed = true;
});
window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') isSpacePressed = false;
});

    function jump() {
        player.vy = -power;
        player.vx = (power * 0.4) * jumpDirection;
        player.isJumping = true;
        player.standingOn = null; // 점프 시 발판에서 분리
        jumpDirection *= -1;
        playJumpSound();
    }

    function initPlatforms() {
        platforms = [];
        for (let i = 1; i <= 20; i++) addPlatform(i);
    }

    function addPlatform(index) {
        const minWidth = 30;
        const baseWidth = 100;
        const platformHeight = 15;
        let dynamicWidth = Math.max(minWidth, baseWidth - (index * 0.2)); 
        
        let speed = 0;
        // curH 2000 근처(index 150)부터 연속 출현 방지 로직 적용
        if (index > 150 && (index - lastMovingIndex) > 3) {
            if (Math.random() < 0.5) {
                speed = (Math.random() < 0.5 ? 1 : -1) * (2 + Math.min(5, index / 100));
                lastMovingIndex = index;
            }
        }

        let plat = {
            index: index,
            x: Math.random() * (canvas.width - dynamicWidth),
            y: floorY - (index * 135),
            width: dynamicWidth,
            height: platformHeight,
            speed: speed,
            holes: []
        };
        for (let j = 0; j < 3; j++) {
            plat.holes.push({ x: Math.random() * dynamicWidth, y: Math.random() * platformHeight, size: 2 + Math.random() * 4 });
        }
        platforms.push(plat);
    }

    function land(plat) {
        player.vy = 0; 
        player.vx = 0;
        player.isJumping = false;
        player.standingOn = plat; // 착지한 발판 저장
        player.angle = Math.round(player.angle / (Math.PI / 2)) * (Math.PI / 2);
    }

    function update(dt) {
        const timeAdj = dt * 60; 

// 1. 발판 이동 및 캐릭터 동기화
platforms.forEach(plat => {
    if (plat.speed !== 0) {
        const moveStep = plat.speed * timeAdj;
        plat.x += moveStep;

        // [끼임 방지 로직 추가]
        if (plat.x <= 0) {
            plat.x = 0;         // 왼쪽 벽에 붙이기
            plat.speed *= -1;   // 방향 반전
        } else if (plat.x + plat.width >= canvas.width) {
            plat.x = canvas.width - plat.width; // 오른쪽 벽에 붙이기
            plat.speed *= -1;   // 방향 반전
        }

        // 캐릭터가 이 발판 위에 있다면 같이 이동
        if (!player.isJumping && player.standingOn === plat) {
            player.x += moveStep;
            
            // 캐릭터도 벽 밖으로 나가지 않게 보정
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
        }
    }
});

        if (isCharging) {
            power = Math.min(maxPower, power + 0.4 * timeAdj);
        }

        if (player.isJumping) {
            player.x += player.vx * timeAdj;
            player.y += player.vy * timeAdj;
            player.vy += gravity * timeAdj;

            if (player.x + player.width > canvas.width || player.x < 0) {
                player.vx *= -0.7;
                player.x = player.x < 0 ? 0 : canvas.width - player.width;
            }

            if (player.vy > 0) {
                platforms.forEach(plat => {
                    if (player.x + player.width > plat.x && player.x < plat.x + plat.width &&
                        player.y + player.height > plat.y && player.y + player.height < plat.y + plat.height + (player.vy * timeAdj)) {
                        player.y = plat.y - player.height;
                        land(plat);
                    }
                });
            }

            if (player.y >= floorY) {
                player.y = floorY;
                land(null);
            }
        }

        let highestPlatform = platforms[platforms.length - 1];
        if (player.y < highestPlatform.y + 500) {
            for(let k = 1; k <= 10; k++) addPlatform(highestPlatform.index + k);
        }

        // 발판 삭제 로직 (화면 10배 여유)
        if (platforms.length > 200) {
            platforms = platforms.filter(p => p.y < player.y + (canvas.height * 10));
        }

        const screenPositionTarget = canvas.height * 0.7;
        let targetCameraY = Math.min(0, player.y - screenPositionTarget);
        cameraY += (targetCameraY - cameraY) * (cameraSmoothness * timeAdj);
    }

    function playJumpSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    }

    function resizeCanvas() {
        const sw = window.innerWidth;
        const sh = window.innerHeight;
        canvas.style.width = sw > 500 ? "auto" : "100vw";
        canvas.style.height = sw > 500 ? "90vh" : "100dvh";
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const startY = floorY;
    let highScore = parseInt(localStorage.getItem("jumpGame_highScore")) || 0;
    let stars = [];
    for(let i=0; i<100; i++) stars.push({ x: Math.random() * canvas.width, y: -Math.random() * 20000, size: Math.random() * 2 });

    function draw(timestamp) {
        let dt = (timestamp - lastTime) / 1000;
        if (isNaN(dt)) dt = 0;
        lastTime = timestamp;
        if (dt > 0.1) dt = 0.1;

        update(dt);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        let altitude = Math.min(1, Math.abs(cameraY) / 20000);
        ctx.fillStyle = `rgb(${Math.floor(135-125*altitude)}, ${Math.floor(206-196*altitude)}, ${Math.floor(235-215*altitude)})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(0, -cameraY);

        ctx.fillStyle = "white";
        stars.forEach(s => { ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); });

        const groundBase = floorY + 40;
        ctx.fillStyle = "#8B4513"; ctx.fillRect(0, groundBase, canvas.width, 2000); 
        ctx.fillStyle = "#228B22"; ctx.fillRect(0, groundBase, canvas.width, 40);

        platforms.forEach(plat => {
            ctx.save();
            ctx.beginPath(); ctx.rect(plat.x, plat.y, plat.width, plat.height); ctx.clip();
            // 움직이는 발판은 색상을 다르게 표시 (선택 사항)
           ctx.fillStyle = "#FFD700";
            ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
            ctx.fillStyle = "#E6B800";
            plat.holes.forEach(h => { ctx.beginPath(); ctx.arc(plat.x + h.x, plat.y + h.y, h.size, 0, Math.PI*2); ctx.fill(); });
            ctx.restore();
        });

        ctx.save();
        ctx.translate(player.x + player.width/2, player.y + player.height/2);
        if (player.isJumping) player.angle += (player.vx > 0 ? 0.2 : -0.2) * (dt * 60);
        ctx.rotate(player.angle);
        draw8GridBlockyPlayer(ctx, -player.width/2, -player.height/2, player.width, player.height);
        ctx.restore();

        if (isCharging) {
            ctx.fillStyle = "#ccc"; ctx.fillRect(player.x, player.y - 20, player.width, 10);
            ctx.fillStyle = "#e74c3c"; ctx.fillRect(player.x, player.y - 20, (power/maxPower)*player.width, 10);
        }

        ctx.restore();

        const curH = Math.max(0, Math.floor((startY - player.y) / 10));
        if (curH > highScore) { highScore = curH; localStorage.setItem("jumpGame_highScore", highScore); }

        ctx.font = "bold 16px Arial";
        ctx.fillStyle = "black"; ctx.fillText(`최고: ${highScore}`, 21, 41); ctx.fillText(`높이: ${curH}`, 21, 71);
        ctx.fillStyle = "#f1c40f"; ctx.fillText(`최고: ${highScore}`, 20, 40);
        ctx.fillStyle = "white"; ctx.fillText(`높이: ${curH}`, 20, 70);

        if (curH < 500) {
            ctx.font = "bold 16px Arial";
            ctx.fillStyle = "white";
	ctx.textAlign = "center";
            ctx.fillText(jumpDirection === 1 ? "다음 점프 방향 >>" : "<< 다음 점프 방향", 201, 51);

            ctx.fillStyle = "black";
	ctx.textAlign = "center";
            ctx.fillText(jumpDirection === 1 ? "다음 점프 방향 >>" : "<< 다음 점프 방향", 200, 50);

ctx.textAlign = "left";
        }

        requestAnimationFrame(draw);
    }

    initPlatforms();
    requestAnimationFrame(draw);
</script>
</body>
</html>