<!DOCTYPE html>
<html lang="ko">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    <title>Jump Game - Balanced</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            height: 100dvh; 
            background-color: #f0f0f0;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
        #gameCanvas {
            background-color: #222;
            border: 5px solid #333;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 100%;
            max-height: 100vh; 
            object-fit: contain; 
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="700"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- [1. 오디오 시스템] ---
    let audioCtx = null;
    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }

    const gravity = 0.5;
    const floorY = canvas.height - 60;

    const player = {
        angle: 0,
        width: 64,
        height: 64,
        x: (canvas.width / 2) - 32,
        y: floorY,
        vx: 0,
        vy: 0,
        isJumping: false
    };

    function draw8GridBlockyPlayer(ctx, x, y, width, height) {
        const gridSize = 8;
        const pixelSize = width / gridSize;
        const colors = {
            hair: "#BCA9E1", skin: "#FFF0ED", ribbon: "#E74C3C",
            top: "#FFFFFF", sock: "#565056", eye1: "#66A1DA", eye2: "#FBB76F"
        };
        ctx.save();
        const p = (gx, gy, color) => {
            ctx.fillStyle = color;
            ctx.fillRect(x + gx * pixelSize, y + gy * pixelSize, pixelSize + 0.5, pixelSize + 0.5);
        };
        p(1, -1, colors.hair); p(6, -1, colors.hair);
        for(let i=0; i<8; i++) p(i, 0, colors.hair);
        for(let i=0; i<8; i++) p(i, 1, colors.hair);
        for(let j=2; j<=4; j++) {
            p(0, j, colors.hair); for(let i=1; i<7; i++) p(i, j, colors.skin); p(7, j, colors.hair);
        }
        p(2, 3, colors.eye1); p(5, 3, colors.eye2);
        p(3, 2, colors.hair); p(4, 2, colors.hair);
        p(0, 5, colors.top); p(1, 5, colors.top);
        p(2, 5, colors.ribbon); p(5, 5, colors.ribbon);
        p(3, 5, colors.top); p(4, 5, colors.top);
        p(6, 5, colors.top); p(7, 5, colors.top);
        for(let i=1; i<7; i++) p(i, 6, colors.ribbon);
        p(0, 6, colors.top); p(7, 6, colors.top);
        p(1, 7, colors.sock); p(2, 7, colors.sock);
        p(5, 7, colors.sock); p(6, 7, colors.sock);
        ctx.restore();
    }

    let power = 0;
    let isCharging = false;
    const maxPower = 20;
    let jumpDirection = 1;
    let platforms = [];
    let cameraY = 0;
    const cameraSmoothness = 0.2;
    let lastTime = 0;

    function startCharge() {
        initAudio();
        if (!player.isJumping) {
            isCharging = true;
            power = 0;
        }
    }

    function endCharge() {
        if (isCharging) {
            jump();
            isCharging = false;
        }
    }

    window.addEventListener('mousedown', startCharge);
    window.addEventListener('mouseup', endCharge);
    canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startCharge(); }, { passive: false });
    canvas.addEventListener('touchend', (e) => { e.preventDefault(); endCharge(); }, { passive: false });

    function jump() {
        player.vy = -power;
        player.vx = (power * 0.4) * jumpDirection;
        player.isJumping = true;
        jumpDirection *= -1;
        playJumpSound();
    }

    function initPlatforms() {
        platforms = [];
        for (let i = 1; i <= 20; i++) addPlatform(i);
    }

let lastMovingIndex = 0; 

function addPlatform(index) {
    const minWidth = 30;
    const baseWidth = 100;
    const platformHeight = 15;
    let dynamicWidth = Math.max(minWidth, baseWidth - (index * 0.2)); 
    
    let speed = 0;
    
    // [조건 추가] 
    // 1. index가 150(약 2000점) 이상이고
    // 2. 마지막 움직이는 발판으로부터 최소 3칸 이상 떨어졌을 때만 (연속 출현 방지)
    // 3. 50%의 확률로 움직이게 설정
//(index - lastMovingIndex) > 5로 숫자를 키우면 움직이는 발판이 훨씬 드문드문 나옵니다.
//더 예측 불가능한 게임: Math.random() < 0.3으로 확률을 낮추면 움직이는 발판이 언제 나올지 몰라 더 긴장감 있게 변합니다.
    if (index > 150 && (index - lastMovingIndex) > 3) {
        if (Math.random() < 0.5) {
            speed = (Math.random() < 0.5 ? 1 : -1) * (2 + Math.min(5, index / 100));
            lastMovingIndex = index; // 마지막으로 움직인 위치 기록
        }
    }

    let plat = {
        index: index,
        x: Math.random() * (canvas.width - dynamicWidth),
        y: floorY - (index * 135),
        width: dynamicWidth,
        height: platformHeight,
        speed: speed,
        holes: []
    };
    
    for (let j = 0; j < 3; j++) {
        plat.holes.push({ x: Math.random() * dynamicWidth, y: Math.random() * platformHeight, size: 2 + Math.random() * 4 });
    }
    platforms.push(plat);
}

    // --- [물리 엔진 시간 보정 적용] ---
    function update(dt) {
        // 기준 프레임(60fps) 대비 시간 배율 계산
        const timeAdj = dt * 60; 

// --- [추가: 발판 이동 로직] ---
    platforms.forEach(plat => {
        if (plat.speed !== 0) {
            plat.x += plat.speed * timeAdj;

            // 벽에 부딪히면 반대로 튕기기
            if (plat.x <= 0 || plat.x + plat.width >= canvas.width) {
                plat.speed *= -1;
            }
        }
    });

        if (isCharging) {
            power = Math.min(maxPower, power + 0.4 * timeAdj);
        }

        if (player.isJumping) {
            player.x += player.vx * timeAdj;
            player.y += player.vy * timeAdj;
            player.vy += gravity * timeAdj;

            if (player.x + player.width > canvas.width || player.x < 0) {
                player.vx *= -0.7;
                player.x = player.x < 0 ? 0 : canvas.width - player.width;
            }

            if (player.vy > 0) {
                platforms.forEach(plat => {
                    if (player.x + player.width > plat.x && player.x < plat.x + plat.width &&
                        player.y + player.height > plat.y && player.y + player.height < plat.y + plat.height + (player.vy * timeAdj)) {
                        player.y = plat.y - player.height;
                        land();
                    }
                });
            }

            if (player.y >= floorY) {
                player.y = floorY;
                land();
            }
        }

        let highestPlatform = platforms[platforms.length - 1];
        if (player.y < highestPlatform.y + 200) {
            for(let k = 1; k <= 10; k++) addPlatform(highestPlatform.index + k);
        }

// 발판이 200개 이상 쌓였을 때만 삭제 시작
if (platforms.length > 200) {
    // 플레이어 위치보다 화면 10개 높이 만큼 더 아래에 있는 것만 삭제
    platforms = platforms.filter(p => p.y < player.y + (canvas.height * 10));
}

	// 3. 카메라 이동 로직
        const screenPositionTarget = canvas.height * 0.7;
        let targetCameraY = Math.min(0, player.y - screenPositionTarget);
        // 카메라 부드러움도 시간 보정
        cameraY += (targetCameraY - cameraY) * (cameraSmoothness * timeAdj);
    }

    function land() {
        player.vy = 0; player.vx = 0;
        player.isJumping = false;
        player.angle = Math.round(player.angle / (Math.PI / 2)) * (Math.PI / 2);
    }

    function playJumpSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    }

    function resizeCanvas() {
        const sw = window.innerWidth;
        const sh = window.innerHeight;
        canvas.style.width = sw > 500 ? "auto" : "100vw";
        canvas.style.height = sw > 500 ? "90vh" : "100dvh";
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const startY = floorY;
    let highScore = parseInt(localStorage.getItem("jumpGame_highScore")) || 0;
    let stars = [];
    for(let i=0; i<100; i++) stars.push({ x: Math.random() * canvas.width, y: -Math.random() * 20000, size: Math.random() * 2 });

    function draw(timestamp) {
        // Delta Time 계산
        let dt = (timestamp - lastTime) / 1000;
        if (isNaN(dt)) dt = 0;
        lastTime = timestamp;
        if (dt > 0.1) dt = 0.1; // 렉 발생 시 튐 방지

        update(dt); // 물리 업데이트

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        let altitude = Math.min(1, Math.abs(cameraY) / 20000);
        ctx.fillStyle = `rgb(${Math.floor(135-125*altitude)}, ${Math.floor(206-196*altitude)}, ${Math.floor(235-215*altitude)})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(0, -cameraY);

        ctx.fillStyle = "white";
        stars.forEach(s => { ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); });

        const groundBase = floorY + 40;
        ctx.fillStyle = "#8B4513"; ctx.fillRect(0, groundBase, canvas.width, 2000); 
        ctx.fillStyle = "#228B22"; ctx.fillRect(0, groundBase, canvas.width, 40);

        platforms.forEach(plat => {
            ctx.save();
            ctx.beginPath(); ctx.rect(plat.x, plat.y, plat.width, plat.height); ctx.clip();
            ctx.fillStyle = "#FFD700"; ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
            ctx.fillStyle = "#E6B800";
            plat.holes.forEach(h => { ctx.beginPath(); ctx.arc(plat.x + h.x, plat.y + h.y, h.size, 0, Math.PI*2); ctx.fill(); });
            ctx.restore();
        });

        ctx.save();
        ctx.translate(player.x + player.width/2, player.y + player.height/2);
        if (player.isJumping) player.angle += (player.vx > 0 ? 0.2 : -0.2) * (dt * 60); // 회전 속도 보정
        ctx.rotate(player.angle);
        draw8GridBlockyPlayer(ctx, -player.width/2, -player.height/2, player.width, player.height);
        ctx.restore();

        if (isCharging) {
            ctx.fillStyle = "#ccc"; ctx.fillRect(player.x, player.y - 20, player.width, 10);
            ctx.fillStyle = "#e74c3c"; ctx.fillRect(player.x, player.y - 20, (power/maxPower)*player.width, 10);
        }

        ctx.restore();

        const curH = Math.max(0, Math.floor((startY - player.y) / 10));
        if (curH > highScore) { highScore = curH; localStorage.setItem("jumpGame_highScore", highScore); }

        ctx.font = "bold 16px Arial";
        ctx.fillStyle = "black"; ctx.fillText(`최고: ${highScore}`, 21, 41); ctx.fillText(`높이: ${curH}`, 21, 71);
        ctx.fillStyle = "#f1c40f"; ctx.fillText(`최고: ${highScore}`, 20, 40);
        ctx.fillStyle = "white"; ctx.fillText(`높이: ${curH}`, 20, 70);

 if (curH < 500) 
        {
            ctx.font = "bold 16px Arial";
            ctx.fillStyle = "black";
            ctx.fillText(jumpDirection === 1 ? "다음 점프 ▶" : "다음 점프 ◀", 20, 100);
        }

        requestAnimationFrame(draw);
    }

    initPlatforms();
    requestAnimationFrame(draw);
</script>
</body>
</html>